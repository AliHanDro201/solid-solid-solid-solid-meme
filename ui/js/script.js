// üìå –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
let animationId = null;
let isMuted = true;
let awake = false;
let finalTranscript = "";
let interimTranscript = "";
let singleRequestMode = false;
let micOn   = false;          // –∏—Å—Ç–∏–Ω–Ω—ã–π —Ñ–ª–∞–≥ ‚Äì –ù–ï —Å–∞–º checkbox
let mediaRecorder, analyser, silenceTmr, audioChunks = [];

// üéØ DOMContentLoaded ‚Äì —á—Ç–æ–±—ã –≤—Å—ë DOM –±—ã–ª–æ –≥–æ—Ç–æ–≤–æ
window.addEventListener("DOMContentLoaded", () => {
    
    const toggleButton = document.getElementById("toggleButton");
    const micIcon = document.getElementById("micIcon");
    const messageText = document.getElementById("messageText");
    const chatInput     = document.getElementById("chatInput");

    // üß† –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ UI
    function startListener(text = "–°–ª—É—à–∞—é", holdText = false) {
        micIcon.classList.remove('fa-microphone-lines-slash');
        micIcon.classList.add("mic-active");
        micIcon.classList.add('fa-microphone-lines');
    
        if (toggleButton.disabled) toggleButton.disabled = false;
    
        if (!holdText) {
            messageText.innerHTML = text || (awake ? "–°–ª—É—à–∞—é..." : "—á—Ç–æ —Ö–æ—Ç–∏—Ç–µ?");
        }
    
    }
    function stopListener(text = "", holdText = false, temporary = false) {
        micIcon.classList.remove('fa-microphone-lines');
        micIcon.classList.remove('mic-active');
        micIcon.classList.add('fa-microphone-lines-slash');
    
       
    
        if (!holdText) {
            messageText.innerHTML = text || "–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω –∏ —Å–∫–∞–∂–∏—Ç–µ";
        }
    
        
    }
    let recordingActive = false;
    
    // ‚úÖ TTS ‚Äî –æ–±—ã—á–Ω–æ–µ Web‚ÄëSpeech API
    function speakText(text){
        if(!text?.trim()) return;
        const u = new SpeechSynthesisUtterance(text);
        u.lang = "ru-RU";
        speechSynthesis.speak(u);
    }

    function muteAssistant () {
        isMuted = true;            // –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π —Ñ–ª–∞–≥
        stopListener();            // —Å—Ç–∞–≤–∏–º –∏–∫–æ–Ω–∫—É –∑–∞—á—ë—Ä–∫–Ω—É—Ç–æ–≥–æ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º UI
        console.log("üîá mute –∞–∫—Ç–∏–≤–µ–Ω");
    }
    eel.expose(muteAssistant);
    

    function unmuteAssistant() {
        isMuted = false;
        startListener();
        console.log("üé§ mute –æ—Ç–∫–ª—é—á—ë–Ω, —Å–ª—É—à–∞—é");
    }
    eel.expose(unmuteAssistant);

    // üí¨ –í—ã–≤–æ–¥ —Å–æ–æ–±—â–µ–Ω–∏–π
    const chatMessages = document.getElementById("chatMessages");
    function addMessageToChat(msg, sender="user"){
        const d = document.createElement("div");
        d.className = sender==="user" ? "user-message" : "assistant-message";
        d.textContent = msg;
        chatMessages.appendChild(d);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    
    

    

    
      
      

    async function checkMicrophone() {
        try {
            // –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –¥–æ—Å—Ç—É–ø –∫ –∞—É–¥–∏–æ-–ø–æ—Ç–æ–∫—É
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç—Ä–µ–∫–∏, —á—Ç–æ–±—ã –æ—Å–≤–æ–±–æ–¥–∏—Ç—å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ
            stream.getTracks().forEach(track => track.stop());
            return true;
        } catch (error) {
            console.error("–ú–∏–∫—Ä–æ—Ñ–æ–Ω –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω:", error);
            return false;
        }
    }





















    //////////////////////–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ–º —Ä–µ—á–∏////////////////////////////
    function toggleMic(forceState = !micOn) {   // true¬†=¬†–≤–∫–ª
        micOn = forceState;
        toggleButton.checked = micOn;             // —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º UI
        if (micOn) startRecording(); else stopRecording();
    }

    // –ö–ª–∞–≤–∏—à–∞ ¬´—ë/`¬ª
    document.addEventListener("keydown", e => {
        if (e.key === '`' || e.code === 'Backquote') toggleMic();
    });
    
    // –ö–ª–∏–∫ –ø–æ —Å–ª–∞–π–¥–µ—Ä—É
    toggleButton.addEventListener("change", () => toggleMic(toggleButton.checked));  
    ////////////////–ó–∞–ø—É—Å–∫ / –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–ø–∏—Å–∏////////////////////////////////
    async function startRecording() {
        if (mediaRecorder?.state === "recording") return;
        const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
        mediaRecorder = new MediaRecorder(stream, {mimeType:"audio/webm"});
        audioChunks.length = 0;
        mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
        mediaRecorder.onstop          = onRecordingStop;
        mediaRecorder.start();
          // –∞–Ω–∞–ª–∏–∑ –≥—Ä–æ–º–∫–æ—Å—Ç–∏ –¥–ª—è –ø–∞—É–∑—ã
        const ctx  = new (window.AudioContext||window.webkitAudioContext)();
        analyser   = ctx.createAnalyser();
        const src  = ctx.createMediaStreamSource(stream);
        src.connect(analyser);
        detectSilence();

        startListener("–°–ª—É—à–∞—é‚Ä¶", true);
    }

    function stopRecording() {
    if (mediaRecorder && mediaRecorder.state === "recording"){
        mediaRecorder.stop();          // ‚Üê –≤—ã–∑–æ–≤–µ—Ç onRecordingStop()
    }
    clearTimeout(silenceTmr);
    analyser?.disconnect();
    stopListener("–û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é‚Ä¶", true);
    }
    ////////////////–î–µ—Ç–µ–∫—Ç–æ—Ä —Ç–∏—à–∏–Ω—ã¬†(2¬†—Å)////////////////////////////////
    function detectSilence() {
        const buf = new Uint8Array(analyser.fftSize);
        analyser.getByteTimeDomainData(buf);
        const rms = Math.sqrt(buf.reduce((s,v)=>s+(v-128)**2,0)/buf.length);
      
        if (rms < 5) {                         // ~¬†0,5¬†% –∞–º–ø–ª–∏—Ç—É–¥—ã
            if (!silenceTmr) silenceTmr = setTimeout(stopRecording, 2000);
        } else {
            clearTimeout(silenceTmr); silenceTmr = null;
        }
        if (micOn) requestAnimationFrame(detectSilence);  // —Ü–∏–∫–ª –ø–æ–∫–∞ –º–∏–∫—Ä. –≤–∫–ª—é—á—ë–Ω
    }
//////////////////–û—Ç–ø—Ä–∞–≤–∫–∞ –Ω–∞ Whisper –∏ –¥–∞–ª–µ–µ –≤ GPT/////////////////////////////////////
    async function onRecordingStop() {
        const blob = new Blob(audioChunks, { type:"audio/webm" });
        audioChunks.length = 0;                     // ‚úÖ –æ—á–∏—â–∞–µ–º –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π

        const arrBuf = await blob.arrayBuffer();
        const b64    = btoa(String.fromCharCode(...new Uint8Array(arrBuf)));

        const text   = await eel.transcribe_audio(b64)();
        if (!text.trim()) { toggleMic(false); return; }

        addMessageToChat(text,"user");
        const raw = await eel.process_input(text)();
        const resp = typeof raw === "string" ? JSON.parse(raw) : raw;

        addMessageToChat(resp.gptMessage,"assistant");
        if (!resp.gptMessage.includes("{name}")) speakText(resp.gptMessage);

        toggleMic(false);                                    // –º–∏–∫—Ä–æ—Ñ–æ–Ω –≤—ã–∫–ª.
    }


///////////////////////////////////–ß–∞—Ç‚Äë–ø–æ–ª–µ –±–µ–∑ ¬´–¥—É–±–ª–µ–π¬ª//////////////////////////////////////////
    chatInput.addEventListener("keydown", async e => {
        if (e.key !== "Enter" || !chatInput.value.trim()) return;
        const text = chatInput.value.trim(); chatInput.value="";
        addMessageToChat(text,"user");          // ‚Üê —Ç–æ–ª—å–∫–æ –∑–¥–µ—Å—å –ø–∏—à–µ–º
        const raw  = await eel.process_input(text)();
        const resp = typeof raw === "string" ? JSON.parse(raw) : raw;
        addMessageToChat(resp.gptMessage,"assistant");
        if (!resp.gptMessage.includes("{name}")) speakText(resp.gptMessage);
      });


































/////////////////–î–ó–ê–ô–ù –ò –ê–ù–ò–ú–ê–¶–ò–Ø –ò –ö–û–ï-–ß–¢–û –ü–ï–†–ï–ú–ï–®–ê–ù–ù–û–ï//////////////////////////
    // * Canvas configuration
    const canvas = document.getElementById('animationCanvas');
    const ctx = canvas.getContext('2d');

    // * Setting the intial size and color of the circle animation
    const initialRadius = 50;

    const initialColor = "rgb(194, 189, 255)";
    const listeningColor = "rgb(134, 225, 255)";

    let listening = false;
    let audioPlaying = false;

    initializeCircle(initialColor, initialRadius);

    function initializeCircle(initialColor, initialRadius) {
        /**
         * * This creates the circle that is the focus of the animation.
         * * It then starts the idle animation (pulsate)
         */
        // Draw the initial glowing ball
        ctx.beginPath();
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const gradient = ctx.createRadialGradient(centerX, centerY, initialRadius / 2, centerX, centerY, initialRadius);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)')
        gradient.addColorStop(1, initialColor);
        ctx.fillStyle = gradient;
        ctx.arc(centerX, centerY, initialRadius, 0, Math.PI * 2);
        ctx.fill();

        pulsateAnimation()
    }

    // * Pulsating animation
    function pulsateAnimation() {
        /**
         * * This animation occurs whenever the audio is not playing.
         */

        if (!audioPlaying) {
            // Calculate the pulsation radius based on a sine wave
            const baseRadius = 50; // Initial radius
            const pulsationAmplitude = 2.5; // Amplitude of the pulsation
            const pulsationFrequency = 1.25; // Frequency of the pulsation (in Hz)

            const pulsationPhase = Date.now() * 0.001 * pulsationFrequency; // Phase based on time
            const pulsatingRadius = baseRadius + pulsationAmplitude * Math.sin(pulsationPhase);

            
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw the pulsating ball
            ctx.beginPath();
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const gradient = ctx.createRadialGradient(centerX, centerY, pulsatingRadius / 2, centerX, centerY, pulsatingRadius);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(1, awake ? listeningColor : initialColor); // Use the same initial color
            ctx.fillStyle = gradient;
            ctx.arc(centerX, centerY, pulsatingRadius, 0, Math.PI * 2);
            ctx.fill();

            // Call the function recursively for the pulsating effect

            requestAnimationFrame(() => pulsateAnimation());
        }
    }
    function animate(analyser, dataArray, prevRadius = null) {

        if (audioPlaying) {
            analyser.getByteFrequencyData(dataArray);
        
            // * Calculate the average frequency
            const averageFrequency = dataArray.reduce((sum, value) => sum + value, 0) / dataArray.length;
        
            // * Calculate the ball radius based on the average frequency (with a larger range)
            const minRadius = 50;
            const maxRadius = 125;
            const radius = minRadius + (maxRadius - minRadius) * (averageFrequency / 255);
    
            // * Inside the animate function
            const blueRGB = [134, 225, 255]; // RGB values for pink hue
            const purpleRGB = [255, 190, 242]; // RGB values for purple hue
    
            // * Calculate the RGB values based on audio frequency using pink and purple hues
            const red = Math.round(blueRGB[0] + (purpleRGB[0] - blueRGB[0]) * (averageFrequency / 255));
            const green = Math.round(blueRGB[1] + (purpleRGB[1] - blueRGB[1]) * (averageFrequency / 255));
            const blue = Math.round(blueRGB[2] + (purpleRGB[2] - blueRGB[2]) * (averageFrequency / 255));
    
            // Create the RGB color string
            const color = `rgb(${red}, ${green}, ${blue})`;
        
            // Clear the canvas with a transparent background
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        
            // Draw the glowing ball
            ctx.beginPath();
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const gradient = ctx.createRadialGradient(centerX, centerY, radius / 2, centerX, centerY, radius);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(1, color);
            ctx.fillStyle = gradient;
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fill();
        
            // Call the animate function recursively
            const prevRadius = radius
            requestAnimationFrame(() => animate(analyser, dataArray, prevRadius));
        }
    
        else {
    
            pulsateAnimation()
    
        }
    }
    function startCanvasAnimation() {
        if (animationId) cancelAnimationFrame(animationId);
        animationId = requestAnimationFrame(() => pulsateAnimation());
    }
    
    function stopCanvasAnimation() {
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

























       
  

});